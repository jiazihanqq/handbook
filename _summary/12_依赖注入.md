# 标题

## 用一句话概述
依赖注入可以理解为是一种服务，解决了实例需要new，而造成的彼此相互依赖的问题，不需要关心实例是如何创建，只需要声明类如何创建，使彼此的耦合性降低；    

angular框架帮助我们，用Injector方法自动维护了一段代码，只需要在Injector.create方法中叙述如何创建这样的对象，用来new出所有实例（可以使用injector.get方法获取到依赖池中的类）  
例如：providers:[{provide: Product, useClass: Product}]
或者工厂模式 providers:[{provide: Product, useFactory: ()=>{return Product("大米手机")}}]
还有一些其他的使用方式如 usevalue：
const token = new InjectionToken<string>("baseUrl")，angular自带token方法防止key冲突
providers:[{provide: token, useValue:"http://localhost"}]
默认返回的实例是单例的  

还提供了了一个deps数组，用来描述依赖的类的依赖


三个角色 （在使用的时候，是不用通过injector的方式去声明的，只需要通过@injector注解声明可注入） 
- 提供服务 
 @injectable() 标记为可供注入的服务
- 模块中声明
 在modules中providers数组中提供出来
- 在组件中使用
在构造函数中可以直接使用
## 原理

## 实现

## 使用
应用的场景：http请求数据
## 引申
angular6开始提供一种写法，相当于懒加载，不会被编译到一个文件中（有效的减小文件的体积），只有在使用的时候才会加载：  
@Injectable({  
    providedIn:"root"  
})  
![avatar](./img/20190805213129.png)